Softwares:

1.jdk 11
2.maven
3.IDE - intellij idea community edition
4.docker
..............................................................................................
Spring Boot 

.............................................................................................
					MicroServices
.............................................................................................

Software Development Models:

Domain:
  Banking

Distributed Application Architecture:

Distributed means broken into multiple layers and making them to communicate.

Application has 3 major layers

1.User Interface -  where we present data - Browser,Mobile Apps,Device Apps

2.Biz layer -  where we can process ,accumulate the data.

3.Data Layer - Data Source - RDBMS,NOSQL,FileSystem,External Systems like webservices,Devices


Types of Application arch:

1.Mainframe based arch
  Biz layer and data layer would be the same machine - server 
  UI layer would be in thin clients

2.Micro computer based arch : client server : Network - LAN and WAN 
  2.1. - Single tier arch.
   Biz logic + data layer + ui layer everything in the same machine
  2.2 - two tier arch
   Biz logic + data layer - server
  ui layer in another machine -  client

1989 :  Web and Internet : Web based /Internet based Client Server Arch

1995 after :

2.2 - two tier arch
   Biz logic + data layer - Web Server / Web Containers
  ui layer in another machine -  client - webbrowsers- GUI


2.3 - There tier arch
   Biz logic - Web Server / Web Containers
       |
   Data storage - Database servers
  ui layer in another machine -  client - webbrowsers- GUI

2.4 - N-tier arch
   Biz logic - Web Server / Web Containers  / Application containers
      |              |
   Web Layer   | Biz layer           | Data Layer
     |
  To Get            |
  HTTP request     Services --------- | DAO -----| databases/ Messaging services
  and Process
      
       |
   Data storage - Database servers
  ui layer in another machine -  client - webbrowsers- GUI

Java and Distributed Application Development.


Java is technology created for devices but was tested in networks in order to understand how java achives platform portablity.

Java was created to work on networks.

Java was very suitable for building distributed internet network based and web based Applications.

Java published 3 major editions -  J2SE(JSE),J2EE(JEE),J2ME(JME)

JSE : CORE language features, oo, error handling, databased connectivy.
JEE : Developed for building enterprise distribtued n tier client server web based application.

All java tech based on Specifications ;  any body can implementations.

JEE implementations :

 Servlet,JSP  -> Web layer  + ui layer
 EJB,JPA,Hibernate -> Data Layer
 JMS ->integration layer
 JConnector - integration layer

The above traditional development model is called "Monolithic" Development.


Distributed Enterprise Application Development Model : Java /JEE.

Web App Types

0.Static Web Apps 
   1989 to 1995 -  Where HTML Pages were hard coded , sent to clients

1.Dynamic Content Generation Technology
  1995 to till date
  -CGI - Perl/C++
  -J2EE  - Servlets and JSP
  -ASP  - Microsoft
  -PHP  - Open source

 Drawbacks of the DCG Technology
 - It can render only html pages(documents

2000 : ECommerce : Biz to Biz integration via web and Internet.

WebServices:
   It is program , which can transfer data inform of the document.

Data Interchange Format:
   XML - was taken as univeral data interchange format.

 How to exchange xml documents among systems

Web Services with XML:
   Built SOAP protocal as tranport for sending and receiving XML docments over internet via http : SOAP Web Service.
  SOA - built based on SOAP Webservices

XML based web had lot of limititations: After introduction Mobile Computing:
.............................................................................

REST Full WebServices ;
  very light , json based , any type format can be exchanged over internet.
..............................................................................................
				 JEE and RestFull webservices :Monoloithic


Traditional development , deployment,maitaince

1.Select DOMAIN : Food Order Management application

-Modules
 OrderManagement
   -Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)

 DeliveryManagement
  -Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)
   -Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)
  -Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)
 -Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)
 RestaurantManagement
 -Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)
 Payments
-Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)
 Billing and Invoices
-Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)
 Notifications
-Controller - api
   -Service
   -Repository
  |
 Data Source(sql/nosql)


Deployment:

 The entire application is packed into "single war/jar/ear" and deployed on container - TOMCAT/Weblogic/webSphere.....

Depsite the application is modular , but we have to bundle the appinto single distribution.

Advantages of the above model(monolithic)

1.simple to develop

2.Easy to changes

3.Testing is easy because only single app

4.Easy to scale


Once the app starts growing, 

You have to modify the code, compile,build and deploy
..............................................................................................
				MicroService Architecture


Breaking the application into smaller application.

Develop,test,Build, Deploy Separatly
  The module can be developed as a app by a team of people.

Features:

1. Separate team of people
2. Separate tech stack - java,.net,javascript.
3. Each app has its own database
..............................................................................................

Advantages of MicroServices:

1.It enables the CI && CD for large applications :Automations
2.Services are smaller , easy to maintain.
3.Services are independently deployable -  containers
4.Services are highly scalable - increasing and decreasing app instance instances inside containers.
5.It allows to extends new technologies - no vendor lock
6.It allows better falut management - error management
..............................................................................................
				How to start Microservices architecture
..............................................................................................

Micro Service Architecture pattern language.

Pattern:
  A pattern is a reusable solution to a problem that occurs in a particular contex.


Patterns can be divied into three layers:

1.infrastructure pattern:
     These patterns solve problems that are mostly infrastructure issues outside development.
2.Application infrastructure:
      These patterns solve problem of distrubuted configuration,security
3.Application Patterns
    Purly used by developers in side code
  
  -Communication Style -  HTTP,tcp,protobuff...
  -Discovery
  -Database and transactions
  -Data formats
  -How to handle errors ; Realiblity
..............................................................................................
Patterns Overview:

1.Decomposition

Decompose by business capability
Decompose by subdomain
Self-contained Service
Service per team.

...........................................................................................

Functional Requirement: User story:

The Place Order story. We can expand that story into numerous user scenarios including
this one:
Given a consumer
And a restaurant
And a delivery address/time that can be served by that restaurant
And an order total that meets the restaurant's order minimum
When the consumer places an order for the restaurant
Then consumer's credit card is authorized
And an order is created in the PENDING_ACCEPTANCE state
And the order is associated with the consumer
And the order is associated with the restaurant

Java : class design
 The nouns in the user story will become classes
Consumer,Order,Restaurant,CreditCard


Accept Order user story:

Given an order that is in the PENDING_ACCEPTANCE state
and a courier that is available to deliver the order
When a restaurant accepts an order with a promise to prepare by a particular
time
Then the state of the order is changed to ACCEPTED
And the order's promiseByTime is updated to the promised time
And the courier is assigned to deliver the order


What class 

 Consumer—A consumer who places orders.
 Order—An order placed by a consumer. It describes the order and tracks its status.
 OrderLineItem—A line item of an Order.
 DeliveryInfo—The time and place to deliver an order.
 Restaurant—A restaurant that prepares orders for delivery to consumers.
 MenuItem—An item on the restaurant’s menu.
 Courier—A courier who deliver orders to consumers. It tracks the availability of
the courier and their current location.
 Address—The address of a Consumer or a Restaurant.
 Location—The latitude and longitude of a Courier.

............................................................................................
					Systems operations


Once we have defined domain model, the next step is to identify the requests that application must handle and response it produces.

How to define system operations?

 System operations are defined by an "API".

API : Application Program interface
 
  It is method/function called , executed, returns some data.

How to communicate api?

  via Protocals - can be http,tcp,domain specific

How to represent api?

API :
   - Web Service
	=>REST FULL  /SOAP - Soap is not recommended - HTTP.
        =>GraphQL
    -RPC
       =>Grpc is implementation  from the google.
    
    -Messaging
        =>Messaging Middlewares - rabbitmq,kaffka ,ActiveMQ......

  
There are two types of system operations:

1.Commands—System operations that create, update, and delete data
2.Queries—System operations that read (query) data
...........................................................................................
1.Domain
2.Service 
3.Api
..............................................................................................
				Implementation
.............................................................................................

How to start writing microservices?

Microservices are platform and language and framework independant.

Java  as Micro service implemenation technology.

Java provides lot of frameworks to build microservices

1.Spring Cloud on Spring Boot.
   Spring cloud is framework which implements most of the microservices "pattern language".

2.Quarkus
    Cloud Native Microservice framework based on Microprofile specs , Microservices on J2EE platforms

3.Ecplise Vertx
    It is toolkit for building Microservices

Java dialects:
  Groovy,Kotlin,Clojurse,Scala

Most of the Dialect languages has there own microservice frameworks

Kotlin
Akka and scala ....
etc.....
..............................................................................................
					Spring Boot
..............................................................................................

Service : 
 = REST
 = GRAPHQL
 = GRPC

Spring is ioc framework, where developer dont need to create object and no need to inject into another - HAS-A

in order to create object and define relationship, we need to tell the spring container.
via
configuration Management
1.xml file
2.java config 
    ->Spring boot


............................................................................................
			Spring Application Configuration Managment
............................................................................................

Spring Application can be configured in many ways

1.XML files  -  Old and Legacy.

2.Java Config + Annotations

2.1 Java Config -Manual - Write Configuration and logic

 Here Dev need to write Configuration and biz logic , which makes app dev slower.

Just Focus logic, automate configuration itself - AutoConfig

3.AutoConfig:
    Framework must take care of configuration based on various condtions like
 i want web and jpa , messaging.
                        "Birth of Spring Boot"

Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".

We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.
..............................................................................................

Spring Framework:
..........................
 beans.xml

  <bean.....>

 Spring Container reads beans.xml , creates beans and makes releationship among them. - DI
............................................................................................
DI automations:
    <bean id="cust" autowire="byType" class="com.valtech.spring.beans.di.autowire.Customer">
        <property name="id" value="1"/>
        <property name="name" value="default"/>
    </bean>
    <bean id="address" class="com.valtech.spring.beans.di.autowire.Address">
        <property name="city" value="coimbatore"/>
    </bean>
...................................................................................
 Container Extensions:
    Enchaning container features.

 -Annotations Processing
 -etc....

Automation - Annoation Scanner
  Reduction boiler plate code for annotation processing.


How to tell spring container to scan annotations?

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

	<context:annotation-config />
	
</beans>

Advanced Annoation: Streo Type annotations; to create bean itself


@Component
@Service
@Repository
@Controller

 <context:annotation-config /> - for JSR 25O annotations
 <context:component-scan base-package="com.valtech.spring.beans.automation"/>


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--scanner for common Annotation -->
    <context:annotation-config/>
    <!--    Scanner for StreoType Annotations-->
    <context:component-scan base-package="com.valtech.spring.beans.automation"/>
</beans>
............................................................................................

Spring Boot is advanced ,automated Configuration System, which reduces boiler plate code.

Spring Boot => [Java Config + Profiles + EnableAnntation]


We take an opinionated view of the Spring platform
   Opinion: what we need for given problem , i want to create simple Web app, with some default datasource.
    "Declarative rules",through which we can create setup and app.

  You dont need to setup web modules, data source modules.....
 

Spring Boot Focus Mainly Configuration

1.Build Configuration
2.Application Configuration.


Spring Boot:

1.Embeded Tomcat.
   Microservices are running in isloation.
2.App distribution is not war
   jar /fat-jar /uber-jar
  fat jar is executable jar, which embeds app code + runtime(tomcat/container).

3.Provide opinionated 'starter' dependencies to simplify your build configuration
     Looks like profie based configuration which is applied even for pom dependencies

4.Automatically configure Spring and 3rd party libraries whenever possible
    Via autoconfiguration and class path scanning.
 		
5.Micro service features are enabled by default
	Provide production-ready features such as metrics, health checks, and externalized configuration
	

Reactive MicroServices:
 In Spring Boot , we can build reactive programming with help of project reactor, spring offers "spring webflux" is wrapper for building reactive microservices.

Running Spring Boot App:

via ide , run main method
via mvn command

windows
mvn spring-boot:run
mvnw spring-boot:run

Linux
./mvnw spring-boot:run
..............................................................................................

Configuration and auto Auto Configuration:

Configuration is for creating beans.

How beans can be created?


 Old Spring
						    - XML
 SpringContainer--------scans ----configuration ---
                                                   - JavaConfig


 SpringContainer--------scans ----@Configuration && @ComponentScan -- config files and classes


 Bean Creation with conditions: @Profiles and @Environment

 SpringContainer--------scans ----@Configuration && @ComponentScan --@Profile('profile') -- config files and classes


In Old spring conditions are very limited: what if want to create beans and configurations based on various rules : Auto Configuration.

Autoconfiguration is automatically creates beans and configurations based on "some declarative rules" -  Conditional Annotations.


Spring Container

 Building config - based on starter dependency.
 bean creations  - based on autoconfiguration
..............................................................................................
				 Microservices - Service Design
.............................................................................................

Patterns lanaguage : Level-0 Service Design.

How to design service?

How to design api?
-REST API
-Graphql api
-rpc api

.............................................................................................
                                 REST
............................................................................................

A Service can be Object, which exposes api, the apis are bound with HTTP Methods/verbs we call 
RESTFULL WebService.

Resource class:

 POJO class , holding data.


RestController:

package com.dell.microservice.rest.api;

import com.dell.microservice.rest.api.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(path = "/api")
public class OrderController {

    @Autowired // Dependency Injection
    private OrderService orderService;

    @GetMapping("/orders")
    public ResponseEntity findAllOrder() {
        return ResponseEntity.ok(orderService.findAllOrder());
    }

    //Return orders based on critera
    @GetMapping("/orders/{name}") //here @PathVariable is done as di which is eq to @Autowired
    public ResponseEntity findOrderByName(@PathVariable(value = "name") String name) {
        List<String> filteredOrders = orderService.findOrderByName(name);
        return ResponseEntity.ok(filteredOrders);
    }

    //http://localhost:8080/api/customers/filter?ranking=prime
    @GetMapping(value = "/customers/filter")//here RequestParam is also di annotation
    public ResponseEntity filter(@RequestParam(value = "ranking") String ranking) {
        List<String> filteredOrders = orderService.findOrderByName(ranking);
        return ResponseEntity.ok(filteredOrders);
    }

}
package com.dell.microservice.rest.api.service;

import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderService {
    List<String> orders = Arrays.asList("Dress", "Phone", "TV");

    public List<String> findAllOrder() {
        return orders;
    }

    //filtered order
    public List<String> findOrderByName(String input) {
        if (input == null) {
            return orders;
        }
        //java streams
        return orders.stream().filter(s -> s.contains(input)).collect(Collectors.toList());
    }
}
.............................................................................................
				Spring Boot and Data Layer : Spring Data
............................................................................................

    <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <!--		jdbc driver-->
		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<scope>runtime</scope>
		</dependency>


package com.dell.microservice.rest.api.entites;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    private String firstName;
    private String lastName;

    protected Customer() {}

    public Customer(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    @Override
    public String toString() {
        return String.format(
                "Customer[id=%d, firstName='%s', lastName='%s']",
                id, firstName, lastName);
    }

    public Long getId() {
        return id;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }
}


package com.dell.microservice.rest.api.dao;

import com.dell.microservice.rest.api.entites.Customer;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface CustomerRepository extends JpaRepository<Customer,Long> {
    //todo: Your own data logic: Most of the CURD OPERATIONS ARE DEFAULT
    List<Customer> findByLastName(String lastName);
    Customer findById(long id);
}

package com.dell.microservice.rest.api;

import com.dell.microservice.rest.api.dao.CustomerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/customers")
public class CustomerController {

    @Autowired
    private CustomerRepository customerRepository;

    @GetMapping("/list")
    public ResponseEntity findAllCustomer() {
        return ResponseEntity.ok(customerRepository.findAll());
    }

    @GetMapping("/{id}")
    public ResponseEntity findCustomerById(@PathVariable(value = "id") Long id) {
        return ResponseEntity.ok(customerRepository.findById(id));
    }
}
..............................................................................................

Deploying spring boot app.

Packaging Format

 -jar -  fat-jar /uber-jar 

A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies). ... Fat JARs are handy when you need to build an executable JAR file, e.g. a microservice executable.

.............................................................................................
			   Spring Boot  Application In Production
............................................................................................

Package the Application:

  -Jar File Model

Spring boot packs the application using jar pattern called "fat jar"/Uber jar..

Legacy Application package format:

1.jar - plain jar
2.war 
3.Ear 

The application packed into war and deployed on Web containers -  Tomcat,Jboss,Weblogic....
 -Monolith style.

MicroServices apps packed small and small apps, deployed on Virtual Envs-  vms,containers.

The application is packaged along containers(embeded container -tomcat,netty)

In order to pack app in optimizted way, the model was dervied called "fat/uber" jar.

The fat jar is suitable for vm envs.

How to create fat jars and how to run it?

mvn clean package

java -jar target/spring-boot-actuator-example-0.0.1-SNAPSHOT.jar
..............................................................................................
				 GraphQL Service Implementation
..............................................................................................

GraphQL is a programming language for building apis.
GraphQL works on top of http protocal only.
GraphQL is web application only.
GraphQL deals data format as json.

Why GraphQL API is better than REST API?


Client -------Request--------->REST API

/api/products => list of products
/api/products/1 => get single product
/api/products/1/reviews/ get review of product 1

/api/products:
 { 
   id
   name
   imageurl
   stock
   qty
   price
   .......
 }

Use case 1 :  /api/products : i want only id,name,imageUrl

Use case 2 :  /api/products : i want only id,name,stock

.........................................................................................

Data Reterival :

 /users - all users

 /users/1 - one user

 /users/1/friends -  one user and his all friends

 /users/1/friends/10 - one user and his single friend details


 /users/1/friends/

  single request-----------single user
				------------friends--multiple records

  composit data : n +1
	 -1 request
            -n
            -n
            -n

.............................................................................................

				REST and GraphQL Spec


GraphQL follows spec.
  Query language spec
  Schema language spec

GraphQL provides two sub set language:

1.GraphQL Query Language  - client side
https://graphql.org/learn/

2.GraphQL Schema Language - Server side
  

GraphQL DGS Implementation:

#Api specification : done via SCHEMA Defintion language

#HTTP Operation type : GET-read, POST-CREATE,PUT-UPDATE,DELETE-REMOVE
#Graphql Operation Type : Query - read, Mutation- CREATE,UPDATE,DELETE, Subscription-streaming
type Query {
    #Operation Name/api name
    hello:String
    movie:Movie
    shows:[Show]
}
type Show {
    title:String
    releaseYear:String
}
type Movie {
    id:ID
    title:String
    hero:Hero
}
type Hero {
    heroId:ID
    name:String
    city:String
}

package com.dell.graphql;

import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;

//Which is service class eq to RestController
@DgsComponent
public class HelloDataFetcher {
    //api
    @DgsQuery(field = "hello")
    public String sayHello() {
        return "Hello GraphQl";
    }
}

package com.dell.graphql;

import com.dell.graphql.models.Hero;
import com.dell.graphql.models.Movie;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsData;

@DgsComponent
public class MovieDataFetcher {

    @DgsData(parentType = "Query",field = "movie")
    public Movie showMovie() {
        return new Movie("1", "Mission Impossible", new Hero("1", "Tom", "New York"));
    }
}

package com.dell.graphql;

import com.dell.graphql.models.Show;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;

import java.util.List;

@DgsComponent
public class ShowDataFetcher {

    @DgsQuery(field = "shows")
    public List<Show> shows() {
        return List.of(new Show("The Mummy", 1999), new Show("The Matrix", 2000));
    }
}
package com.dell.graphql;

import com.dell.graphql.models.Hero;
import com.dell.graphql.models.Movie;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsData;

@DgsComponent
public class MovieDataFetcher {

    @DgsData(parentType = "Query",field = "movie")
    public Movie showMovie() {
        return new Movie("1", "Mission Impossible", new Hero("1", "Tom", "New York"));
    }
}

package com.dell.graphql;

import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;

//Which is service class eq to RestController
@DgsComponent
public class HelloDataFetcher {
    //api
    @DgsQuery(field = "hello")
    public String sayHello() {
        return "Hello GraphQl";
    }
}

package com.dell.graphql.models;

public class Hero {
    private String heroId;
    private String name;
    private String city;

    public Hero(String heroId, String name, String city) {
        this.heroId = heroId;
        this.name = name;
        this.city = city;
    }

    public String getHeroId() {
        return heroId;
    }

    public void setHeroId(String heroId) {
        this.heroId = heroId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

package com.dell.graphql.models;

public class Movie {
    private String id;
    private String title;
    private Hero hero;

    public Movie(String id, String title, Hero hero) {
        this.id = id;
        this.title = title;
        this.hero = hero;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Hero getHero() {
        return hero;
    }

    public void setHero(Hero hero) {
        this.hero = hero;
    }
}

package com.dell.graphql.models;

public class Show {
    private String title;
    private int releaseYear;

    public Show(String title, int releaseYear) {
        this.title = title;
        this.releaseYear = releaseYear;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public int getReleaseYear() {
        return releaseYear;
    }

    public void setReleaseYear(int releaseYear) {
        this.releaseYear = releaseYear;
    }
}


Mutation:
type Mutation {
    addRating(input:RatingInput):Rating
}

input RatingInput {
    title:String
    stars:Int
}

type Rating {
    avgStars:Int
}
package com.dell.graphql;

import com.dell.graphql.models.Rating;
import com.dell.graphql.models.RatingInput;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsMutation;
import com.netflix.graphql.dgs.InputArgument;

@DgsComponent
public class ReviewMutation {

    //add
    @DgsMutation(field = "addRating")
    public Rating addRating(@InputArgument("input") RatingInput ratingInput) {
        //biz logic to save rating into database
        System.out.println("Rated :" + ratingInput.getTitle() + "with " + " " + ratingInput.getStars());
        return new Rating(ratingInput.getStars());
    }
}
package com.dell.graphql.models;


public class RatingInput {
    private String title;
    private Integer stars;


    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Integer getStars() {
        return stars;
    }

    public void setStars(Integer stars) {
        this.stars = stars;
    }
}
package com.dell.graphql.models;

public class Rating {
    private String title;
    private Integer avgStars;

    public Rating(Integer avgStars) {
        this.avgStars = avgStars;
    }

    public Rating(String title, Integer stars) {
        this.title = title;
        this.avgStars = stars;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Integer getStars() {
        return avgStars;
    }

    public void setStars(Integer avgStars) {
        this.avgStars = avgStars;
    }
}
..............................................................................................
			 Micro Services Design pattern Implemenations
..............................................................................................

Micro service are loosly coupled applications , which has apis, can be REST,Graphql,RPC,Messages.

Common Things we need to take of Microservice Development
.........................................................


1.Configuration Management infrastructure

Spring and Microservice Implementation:
.......................................
Spring team provides an project called Spring Cloud.

Spring cloud offers implementation for microservice infrastructure.

1.Distributed/versioned configuration

2.Service registration and discovery

3.Routing

4.Service-to-service calls

4.Load balancing

5.Circuit Breakers

6.Global locks

7.Leadership election and cluster state

8.Distributed messaging
..........................................................................................

If you want to implement microservice apps, we need infrastructure components.

-Service Registry and Discovery
   ->Many people are giving service registeries
      -Consul
      -Apache Zoo Keeper
      -Apache Ignite
      -Netflix
         -Eureka 
      -Kubernets

--etc.....
..............................................................................................
				    Distributed configuration
..............................................................................................


There are two actors in the configuration

1.Configuration Provider
2.Configuration Server/Broker
3.Consumer typically DOMAIN Services


1.Configuration Provider.
 local disk file
 Remote git repos
 LDap server
 noSql severs
 Vaults

Note: Spring cloud config by default provides "git" as backend. 


2.Configuration Server
  Simple Spring Boot Application
  @EnableConfigServer
  Config Server is just simple WebApplication, exposes REST endpoints  behind scene.


3.Configuration Client
   Who uses existing spring PropertyResource and Enviroment Abstractions


How to setup config server?

spring.cloud.config.server.git.uri=https://github.com/spring-cloud-samples/config-repo

 Telling the location of Provider

git location can be github /git lab or local git repository

spring.cloud.config.server.git.uri =  can be http or local file system.

if you are using local git , before using create git repositor

$ cd $HOME
$ mkdir config-repo
$ cd config-repo
$ git init .
$ create this file - test-dev.properties
$ git add  .
$ git commit -m "Add application.properties"

spring.cloud.config.server.git.uri=file:///E:/session/example-app-config

.........................................................................................

Server

pom.xml
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-config-server</artifactId>
		</dependency>
example:

application.properties

server.port=8081
#Basic Config Server Properties
#spring.cloud.config.server.git.uri=https://github.com/spring-cloud-samples/config-repo
spring.cloud.config.server.git.uri=file:///E:/session/example-app-config

package com.dell.microservice.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class MicroserviceConfigServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(MicroserviceConfigServerApplication.class, args);
	}

}

......

client side

pom.xml
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-config</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-bootstrap</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>

bootstrap.properties

spring.cloud.config.uri=http://localhost:8081
spring.application.name=test,test2
spring.profiles.active=dev

application.properties

management.endpoints.web.exposure.include=*


package com.dell.microservice.client;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RefreshScope
public class GreetingController {

    @Value("${test.greeting}")
    private String message;

    @GetMapping("/message")
    String getMessage() {
        return this.message;
    }
}

.....
Auto referesh : Update

POST http://localhost:8080/actuator/refresh
[
    "config.client.version",
    "test.greeting"
]
Check the value


application.properties

We can override these in code, command-line arguments, ServletConfig init parameters, ServletContext init parameters, Java system properties, operating system variables, and application properties file.

An important thing to keep in mind is that these application properties files have the lowest precedence compared to other forms of overriding application context properties.

We tend to group properties that we can override in the application context:

Core properties (logging properties, thread properties)
Integration properties (RabbitMQ properties, ActiveMQ properties)
Web properties (HTTP properties, MVC properties)
Security properties (LDAP properties, OAuth2 properties)

bootstrap.properties

We use bootstrap.yml or bootstrap.properties for configuring the bootstrap context. This way we keep the external configuration for bootstrap and main context nicely separated.

The bootstrap context is responsible for loading configuration properties from the external sources and for decrypting properties in the local external configuration files.

.............................................................................................
				  Vault -Harishop : Distributed Configuration
..........................................................................................

Vault as configuration system.

Steps:

1.Setup vault

install vault binary
install via docker

https://learn.hashicorp.com/tutorials/vault/getting-started-install?in=vault/getting-started

2.start vault server
vault server -dev

3.set env valult add variable
set VAULT_ADDR=http://127.0.0.1:8200

4.You can store data into vault

vault kv put secret/application foo=bar baz=bam
Key                Value
---                -----
created_time       2021-12-22T09:47:07.0739196Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1

1.Create Config Server

pom.xml
<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-config-server</artifactId>
		</dependency>

application.properties /application.yml

spring:
  profiles:
    active: vault
  cloud.config.server.vault.kvVersion: 2
server:
  port: 8888

package org.springframework.cloud.vaultconfigserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class VaultConfigServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(VaultConfigServerApplication.class, args);
	}
}
...........................................................................................

Config Client:
pom.xml
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-config</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-bootstrap</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>

bootstrap.yml /boostrap.properties

spring:
  cloud:
    config:
      token:  s.jEk9S5YVcOi78GcqOtEt660N

Note:
 copy the  token from valut server
 

package org.springframework.cloud.vaultconfigclient;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class VaultConfigClientApplication implements CommandLineRunner {
    Logger LOG = LoggerFactory.getLogger(VaultConfigClientApplication.class);

    @Value("${foo}")
    String foo;

    @Value("${baz}")
    String bar;

    public static void main(String[] args) {
        SpringApplication.run(VaultConfigClientApplication.class, args);
    }

    @GetMapping("/myinfo")
    public ResponseEntity returnValut() {
        return ResponseEntity.ok(foo + " " + bar);
    }

    @Override
    public void run(String... args) throws Exception {
        LOG.info("Foo: " + foo);
        LOG.info("Bar: " + bar);
    }
}
.............................................................................................
				  Service to Service Communication
.............................................................................................	

REST API Communication : REST TO REST.
ONE REST api is consumer and Another REST API is provider.

1.Provider Service

2.Consumer Service

REST:
How rest apis can talk each other.

Spring Boot implemetation

1.RestTemplate
 
 RestTemplate is a synchronous client to perform HTTP requests. It is the original Spring REST client and exposes a simple, template-method API over underlying HTTP client libraries.

2.WebClient
  
 WebClient is a non-blocking, reactive client to perform HTTP requests. It was introduced in 5.0 and offers a modern alternative to the RestTemplate, with efficient support for both synchronous and asynchronous, as well as streaming scenarios.

3.Spring Cloud OpenFeign


RestTemplate
................

 -It is spring bean, so you have to create,

 you can create inside config file or inside main file

 @Bean
  public RestTemplate resttemplate(){
      return new RestTemplate();
 }
getForObject :Retrieves a representation via GET.

getForEntity:Retrieves a ResponseEntity (that is, status, headers, and body) by using GET.

...
server.port=8081

package com.dell.microservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
public class HelloConsumerserviceApplication {

    public static void main(String[] args) {
        SpringApplication.run(HelloConsumerserviceApplication.class, args);
    }

    @Bean
    public RestTemplate resttemplate() {
        return new RestTemplate();
    }
}

package com.dell.microservice;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;


    //call api using rest template
    @GetMapping(value = "/client")
    public ResponseEntity<Hello> helloV1() {
        String url = "http://localhost:8080/hello";
        Hello helloResponse = restTemplate.getForObject(url, Hello.class);
        return ResponseEntity.status(200).body(helloResponse);
    }
}


Start Provider app

Start Consumer app

http://localhost:8081/client

{
message: "I am from HelloController "
}
.............................................................................................

String url = "http://localhost:8080/hello";

The above code works with hardcoded urls

What if the url changes,particulary port changes

incase of Dynamic Ports, ports randomly assinged by cloud/containers...

String url = "http://localhost:{?}/hello";

How to solve this?

 Using DNS
 Using Service Registry and Discovery
..............................................................................................
				Service Registry
.............................................................................................

Sevice Registry:

->It is data base /Data store
  Stores Resources - Service informations - name of the service,ip address, port.....
->It is key-value pair models - NOSQL Based

Service registry is not new concept.
  -DNS servers
  -Naming servers
etc.....

Service Registry Servers:
  
1.Apache ZooKeeper
2.Consul
3.APACHE IGNITE
4.Netflix Eureka
etc.......

Discovery:
 It is process of looking up of services from the Registery Servers

Advantages:

 1.Client Application and Provider Applicaiton dont need to talk directly.
 2.Client Apps dont need to query by extact port and domain name rather than , service name.

Discovery Types ;

1.client-side discovery

2.server-side discovery

Service Disovery:

  Services typically need to call one another.

 In a monolithic application, services invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well known locations (hosts and ports) and so can easily call one another using HTTP/REST or some RPC mechanism. 
 However, a modern microservice-based application typically runs in a virtualized or containerized environments where the number of instances of a service and their locations changes dynamically.


             "Service Discovery is in short , Clients/Consumers are going to locate services"

1.client-side discovery

 =>When using client side discovery the client is responsible for determining the network locations of available services instances and load balance requests across them.

 =>Client queries a service registry, which database of service instances. Then client uses a load balancing algorthim to select one of the available service instances and a make a request.


2.Server side discovery

  =>When using server side discovery, client makes a request to via a load balancer
  =>Loadbalancer quries services instances, returns a reference

..............................................................................................

Client Side Discovery Implementation

1.Netflix Eureka
2.Kubernets
3.Apache ZooKeeper
4.Consul
etc.....


1.Service Registry
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>


2.application.properties
server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
logging.level.com.netflix.eureka=OFF
logging.level.com.netflix.discovery=OFF

3.package com.dell.registry;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class ServiceRegisteryApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServiceRegisteryApplication.class, args);
	}

}
.............................................................................................

Provider Service:
...............

pom.xml
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>


application.properties

eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
spring.application.name=hello-service
server.port=${PORT:0}
eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}


Main Code
package com.hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class HelloServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloServiceApplication.class, args);
	}

}

Run the Client and Test Whether this app has been registered with EUREKA Registry Server

...........................................................................................

Consumer

pom.xml
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>


application.properties

eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
spring.application.name=hello-webclient-service
server.port=${PORT:0}
eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}

package com.hello.client;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
public class HelloWebclientServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloWebclientServiceApplication.class, args);
	}

	@Bean
	RestTemplate restTemplate() {
		return new RestTemplate();
	}
}
..............................................................................................

Service Communication via Eureka Service Registry:
..................................................

 @Autowired
 private DiscoveryClient discoveryClient;


There are different ways through which we can query instances.


1.hardcoded way of getting instances


    @GetMapping("/")
    public String sayHello() {
        return "Hello";
    }

    @GetMapping(value = "/client/dynamic")
    public ResponseEntity helloV2() {
        List<ServiceInstance> instances = discoveryClient.getInstances("hello-service");
        Hello helloResponse = null;
        if (instances != null && instances.size() > 0) {
            ServiceInstance serviceInstance = instances.get(0);
            System.out.println(serviceInstance.getHost() + " " + serviceInstance.getPort() + " " + serviceInstance.getServiceId());
            System.out.println(serviceInstance.getInstanceId());
            String service_Name = serviceInstance.getServiceId();
            String url = "http://" + service_Name + "/hello";
            helloResponse = restTemplate.getForObject(url,
                    Hello.class);
            System.out.println(helloResponse);
        }
        return  ResponseEntity.ok(helloResponse);

    }

The above apporach is too complicated for all use cases.

We need simple solution to talk to rest end points.

 ->Spring Clouding OpenFeign Client.

Declarative REST Client: Feign creates a dynamic implementation of an interface decorated with JAX-RS or Spring MVC annotations



2.Getting Instances via OpenFeign Client

pom.xml
 <dependency>
     <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

package com.hello.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;

//hello-service is name of the service from HelloService
@FeignClient("hello-service")
public interface HelloServiceFeignClient {
    @GetMapping("/hello")
    ResponseEntity<Hello> hello();
}

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
public class HelloWebclientServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloWebclientServiceApplication.class, args);
	}

	@Bean
	RestTemplate restTemplate() {
		return new RestTemplate();
	}
}
.............................................................................................
				    Scalablity
 				  Load Balancing

In Server-side load balancing, the instances of the service are deployed on multiple servers and then a load balancer is put in front of them. It is generally a hardware load balancer. All the incoming requests traffic firstly comes to this load balancer acting as a middle component. It then decides to which server a particular request must be directed to based on some algorithm.

Disadvantages of Server-side load balancing:

Server side load balancer acts as a single point of failure as if it fails, all the instances of the microservice becomes inaccessible as only load balancer has the list of servers.

Since each microservice will have a separate load balancer, the overall complexity of the system increases and it becomes hard to manage.

The network latency increases as the number of hops for the request increases from one to two with the load balancer, one to the load balancer and then another from load balancer to the microservice.


2. Client-side Load Balancing

The instances of the service are deployed on multiple servers. Load balancer's logic is part of the client itself, it holds the list of servers and decides to which server a particular request must be directed to based on some algorithm. These client side load balancers are also known as software load balancers.

Disadvantages of Client-side load balancing
The load balancer's logic is mixed up with the microservice code.


............................

Server side Load balancer is very usefull to manage trafic from outside applications.
Mobile clients and webclients trafic easily can be managed.

Client side load balancers are very usefull to mangae trafic inside microservice application.


Netflix Ribbon:

Netflix Ribbon is a Part of Netflix Open Source Software (Netflix OSS). It is a cloud library that provides the client-side load balancing. ... The Ribbon mainly provides client-side load balancing algorithms. It is a client-side load balancer that provides control over the behavior of HTTP and TCP client.

Ribbon is a Inter Process Communication (remote procedure calls) library with built in software load balancers. The primary usage model involves REST calls with various serialization scheme support


Following are the features of Ribbon:

Load balancing: It provides client side load balancing functionality.

Fault tolerance: It can be used to determine whether the servers are up or not and can also detect those servers that are down and hence, ignore them for sending the further requests.

Configurable load balancing rules: 

By default ribbon uses RoundRobinRule for distributing requests among servers.

In addition to it, it also provides AvailabilityFilteringRule and WeightedResponseTimeRule.

We can also define our custom rules as per our needs.

Eg:
        @LoadBalanced
	@Bean
	RestTemplate restTemplate() {
		return new RestTemplate();
	}


How to test client side balancing?
...................................

Run the application in multiple copies

>java -jar target/hello-service-0.0.1-SNAPSHOT.jar

>java -jar target/hello-service-0.0.1-SNAPSHOT.jar

>java -jar target/hello-service-0.0.1-SNAPSHOT.jar

>java -jar target/hello-service-0.0.1-SNAPSHOT.jar


****************************************XXXXXXXXX*********************************************					 Server Side Load balancer- API GateWay


Zull API Gate Way:
.................

Zuul is a gateway service that provides dynamic routing, monitoring, resiliency, security, and more.

=>Zull is entry point to Micro Services Apps

=>filtering  logics

=>Request Transfermation

=>Authentication

=>Dynamic routing

example.com ====>ApiGateWay ==> myapp


Filter /Interceptor:

  It is logic gets executed before any request processing starts


Client ---request---/api/something----------|filter---filter--filter--|requestProcessing logic starts

if we want the same concept for mircoservice architecture, that is called as "GateWay/EdgeService/LoadBalancer / Routers&Filters"


Embedded Zuul Reverse Proxy
.............................

Spring Cloud has created an embedded Zuul proxy to ease the development of a common use case where a UI application wants to make proxy calls to one or more back end services.


This feature is useful for a user interface to proxy to the back end services it requires, avoiding the need to manage CORS and authentication concerns independently for all the back ends.

To enable it, annotate a Spring Boot main class with @EnableZuulProxy. Doing so causes local calls to be forwarded to the appropriate service. By convention, a service with an ID of users receives requests from the proxy located at /users (with the prefix stripped). The proxy uses Ribbon to locate an instance to which to forward through discovery. All requests are executed in a hystrix command, so failures appear in Hystrix metrics. Once the circuit is open, the proxy does not try to contact the service.

..............................................................................................

Steps:

Zull Proxy Creation:


1.Zull is WebApplication only

Create SpringBoot App, add 
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>




2.Enable Zuul

package com.example.routingandfilteringgateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.Bean;
import com.example.routingandfilteringgateway.filters.pre.SimpleFilter;

@EnableZuulProxy
@SpringBootApplication
public class RoutingAndFilteringGatewayApplication {

  public static void main(String[] args) {
    SpringApplication.run(RoutingAndFilteringGatewayApplication.class, args);
  }

  @Bean
  public SimpleFilter simpleFilter() {
    return new SimpleFilter();
  }


}

Filter
package com.example.routingandfilteringgateway.filters.pre;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.http.HttpServletRequest;

public class SimpleFilter extends ZuulFilter {

    private static Logger log = LoggerFactory.getLogger(SimpleFilter.class);

    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        log.info(String.format("%s request to %s", request.getMethod(), request.getRequestURL().toString()));

        return null;
    }

}

application.properties
#Routing rules
zuul.routes.books.url=http://localhost:8090
#zuul.routes.customers.url=http://localhost:8081
ribbon.eureka.enabled=false
server.port=8080
server.port=8080

.......................................................................................
Micro Service Code:
.................

package com.example.routingandfilteringbook;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@SpringBootApplication
public class RoutingAndFilteringBookApplication {

  @RequestMapping(value = "/available")
  public String available() {
    return "Spring in Action";
  }

  @RequestMapping(value = "/checked-out")
  public String checkedOut() {
    return "Spring Boot in Action";
  }

  public static void main(String[] args) {
    SpringApplication.run(RoutingAndFilteringBookApplication.class, args);
  }
}

application.properties
spring.application.name=book
server.port=8090

Testing:
Request to Proxy/API Gate Way Server. which intern routes the request to Backend Services
http://localhost:8080/books/checked-out
............................................................................................
				  MicroService Reslience Patterns
............................................................................................










  



























 








































































